// This file is @generated by prost-build.
// This proto is in "immutable" because it's shared between Rust code and external interfaces.
// Also: given these fields are mandated by the spec, we should not change these protos very often, if at all

// Note: another reason why these have to be immutable: some of these protos are used in our intents.

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKeyCredentialDescriptor {
    /// Must be literal string "public-key"
    #[prost(string, tag="1")]
    pub r#type: ::prost::alloc::string::String,
    /// ENCODING: base64url
    #[prost(string, tag="2")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration="AuthenticatorTransport", repeated, packed="false", tag="3")]
    pub transports: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatorAssertionResponse {
    /// ENCODING: base64url
    #[prost(string, tag="1")]
    pub client_data_json: ::prost::alloc::string::String,
    /// ENCODING: base64url
    #[prost(string, tag="2")]
    pub authenticator_data: ::prost::alloc::string::String,
    /// ENCODING: base64url
    #[prost(string, tag="3")]
    pub signature: ::prost::alloc::string::String,
    /// NOTE(keyan): The (TypeScript) spec says this field is non-optional but nullable, i.e.
    ///    `userHandle: string | null`
    ///
    /// What we have here is optional and nullable:
    ///    `userHandle?: string | null`
    ///
    /// We need it to be optional because the field needs to be nil-able in go.
    /// However, a future version of TypeScript (w/ stricter options) might not like the type.
    #[prost(string, optional, tag="4")]
    pub user_handle: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatorAttestationResponse {
    /// ENCODING: base64url
    #[prost(string, tag="1")]
    pub client_data_json: ::prost::alloc::string::String,
    /// ENCODING: base64url
    #[prost(string, tag="2")]
    pub attestation_object: ::prost::alloc::string::String,
    #[prost(enumeration="AuthenticatorTransport", repeated, packed="false", tag="3")]
    pub transports: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, optional, tag="4")]
    pub authenticator_attachment: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKeyCredentialWithAttestation {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Must be literal string "public-key"
    #[prost(string, tag="2")]
    pub r#type: ::prost::alloc::string::String,
    /// ENCODING: base64url
    #[prost(string, tag="3")]
    pub raw_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag="4")]
    pub authenticator_attachment: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="5")]
    pub response: ::core::option::Option<AuthenticatorAttestationResponse>,
    #[prost(message, optional, tag="6")]
    pub client_extension_results: ::core::option::Option<SimpleClientExtensionResults>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKeyCredentialWithAssertion {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// Must be literal string "public-key"
    #[prost(string, tag="2")]
    pub r#type: ::prost::alloc::string::String,
    /// ENCODING: base64url
    #[prost(string, tag="3")]
    pub raw_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag="4")]
    pub authenticator_attachment: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="5")]
    pub response: ::core::option::Option<AuthenticatorAssertionResponse>,
    #[prost(message, optional, tag="6")]
    pub client_extension_results: ::core::option::Option<SimpleClientExtensionResults>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleClientExtensionResults {
    #[prost(bool, optional, tag="1")]
    pub appid: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="2")]
    pub appid_exclude: ::core::option::Option<bool>,
    #[prost(message, optional, tag="3")]
    pub cred_props: ::core::option::Option<CredPropsAuthenticationExtensionsClientOutputs>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CredPropsAuthenticationExtensionsClientOutputs {
    #[prost(bool, tag="1")]
    pub rk: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthenticatorTransport {
    Unspecified = 0,
    Ble = 1,
    Internal = 2,
    Nfc = 3,
    Usb = 4,
    Hybrid = 5,
}
impl AuthenticatorTransport {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AuthenticatorTransport::Unspecified => "AUTHENTICATOR_TRANSPORT_UNSPECIFIED",
            AuthenticatorTransport::Ble => "AUTHENTICATOR_TRANSPORT_BLE",
            AuthenticatorTransport::Internal => "AUTHENTICATOR_TRANSPORT_INTERNAL",
            AuthenticatorTransport::Nfc => "AUTHENTICATOR_TRANSPORT_NFC",
            AuthenticatorTransport::Usb => "AUTHENTICATOR_TRANSPORT_USB",
            AuthenticatorTransport::Hybrid => "AUTHENTICATOR_TRANSPORT_HYBRID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUTHENTICATOR_TRANSPORT_UNSPECIFIED" => Some(Self::Unspecified),
            "AUTHENTICATOR_TRANSPORT_BLE" => Some(Self::Ble),
            "AUTHENTICATOR_TRANSPORT_INTERNAL" => Some(Self::Internal),
            "AUTHENTICATOR_TRANSPORT_NFC" => Some(Self::Nfc),
            "AUTHENTICATOR_TRANSPORT_USB" => Some(Self::Usb),
            "AUTHENTICATOR_TRANSPORT_HYBRID" => Some(Self::Hybrid),
            _ => None,
        }
    }
}
